# Object Oriented Programming?
난 대학교 CS전공 2학년 때 OOP에 대해 배웠다. 아니 정확히는 고등학교 1학년 때, 이미 OOP에 대해서 접했다. 하지만 OOP 공부에 쏟은 시간은 대학교 2학년 때가 더 기니 2학년 때 배웠다고 하는게 맞을 거다. 그렇지만 웃기게도 이번에 스터디를 하면서 느꼈다. 오히려 고등학교 때 1주 정도의 시간을 내어 OOP에 대해 공부한게 오히려 1학기를 전부 할애한 것보다 OOP의 본질적인 부분을 좀 더 파고들어 학습했다고 느꼈다.

얼마 전에 OOP가 뭘까에 대해서 고민하기 시작했다. 디자인 패턴을 공부하면서 클래스와 객체를 쓰는 테크닉을 종종 보긴 했는데 정작 OOP의 본질은 무엇인지 탐구하지는 않았던 것 같다. 그래서 한동안은 OOP가 클래스를 바탕으로 객체를 생성해서 객체를 이용해 다음의 특성들을 이용해 프로그래밍을 하는 것이라고 생각했다. 
- **추상화**
- **캡슐화**
- **상속**
- **다형성**

이는 틀린 말은 아니지만 OOP를 공부해나가고 있는 지금 돌이켜보면 핵심을 담고 있는 이야기는 전혀 아닌 것 같다. OOP의 핵심은 항상 변할 것으로 기대되는 요구사항에 대항하기 위해 객체 간의 협력을 이용하여 문제를 해결해나간다는 점이다. 여기서 주목해야 할 점은 항상 변할 것이라는 점인데 OOP는 변화에 빠르고 유연하게 대응하기 위한 일종의 방법론이다. 항상 변하는 것에 맞서고 있기 때문에 OOP는 점진적으로 변해간다는 특성도 함께 갖고 있다.

OOP는 처음 들어보면 별게 아닌 것처럼 느끼고 처음 코딩을 배울 때와 뭐가 다른 건지 애매할 때가 있다. 왜 이런 걸까? 내 생각에 그 이유는 처음 코딩을 배울 때는 절차적으로 생각하는 방법에 익숙해서 그런 것 같다.
## 절차지향 vs 객체지향
처음 C언어를 배울 때, 책의 저자와 주변 사람들이 C언어는 절차적인 프로그래밍을 따른다고 했다. 자신이 원하는 일을 하기 위해 논리를 절차적으로 이어나가는 모습에 그렇게 부른다고 당시에는 이해했었다. 그러고 C++를 접하면서 객체지향 프로그래밍을 접하게 되었는데 위에서 언급한 모든 특성을 다 배우고 내가 처음 느낀 소감은...
"...? 이것도 절차적인 논리를 따라가지 않나...?" 라고 당시에 생각했고 다만 객체지향은 절차지향과 다르게 실제 사물들이 자율적으로 움직이게끔 개념을 구현한다고 생각했다.

이것 또한 위와 마찬가지로 틀린 말은 아니지만 핵심은 아닌 것 같다. 객체지향과 절차지향의 핵심적인 차이는 어떤 목적을 수행하기 위한 오퍼레이션이 각각의 모듈에 짜임새 있게 위치해 있는가 인 것 같다. 이는 단순히 클래스를 이용해 객체를 생성하고, 이 인스턴스를 대상으로 멤버함수(메서드)를 호출해 원하는 것을 처리한다고 해서 객체지향이라고 볼 수 없다는 것을 시사한다.

위와 같은 핵심을 갖기 때문에 OOP는 유지보수성에 대해서 큰 강점을 갖게 된다. 이는 서비스의 규모가 커지거나 코드가 점점 길어질 때, 효과적으로 프로젝트의 복잡성을 낮추는데 기여를 한다.

하지만 이렇게 말하면 객체지향이 절대적으로 좋고 절차지향은 구시대의 잔재 같은 것으로 보이게 만든다. 절차지향은 논리적으로 생각했을 때, 자판기에서 콜라를 뽑아마시는 방법(절차)을 인간이 단계적으로 생각하는 방식과 흡사하기 때문에 자연스럽다고 느껴진다. 또한 데이터의 구조를 이해하고 해당 구조에 맞는 연산을 적용해 원하는 바를 이루는 과정에서 필연적으로 데이터의 특성을 고려하게 되어 효율적인 사고(알고리즘)를 하는 훈련을 돕는다. 객체지향은 이러한 특징들을 감추어 다른 특성을 강조한다. 효율보다 명료함. 바로 그것이다. 

## 객체지향이 객체지향 다울 때
위와 같은 본질과 강점들은 클래스와 객체를 쓰기만 하면 얻어질까? 당연히 아닐 것이다. 객체지향이 객체지향 다운 코드가 되려면 핵심을 관통하게끔 설계를 진행해야 한다. 단순히 객체에서 다른 객체의 메소드를 호출해서 값을 가져와 오퍼레이션을 동작시킨다고 능사가 아니다.

핵심을 관통하려면 객체는 <ins>자율적인 존재이며 늘 다른 이와 협력해야 어떤 의미가 있다는 것</ins>을 이해해야 한다. 이것이 바로 **책임**, **역할**, **협력**이다. 그리고 이러한 개념들은 모두 나라는 개념을 기준으로 도와주고, 도움을 받는 다른 존재들이 있다는 것을 인지하는게 중요하다. 특정 객체에게 어떤 문제를 해결하기 위한 책임을 부여한다. 그리고 그 객체가 자신의 책임을 다하기 위한 세부 작업을 진행하면서 새로운 객체에게 그 세부 작업에 대한 책임을 갖는 객체에게 협력을 요청한다. 이러한 책임들이 모여 역할이라는 명패를 객체들에게 부여한다.

나를 기준으로 다양한 상호작용이 왔다갔다하는 현상을 보고 프로그래머라면 쉽게 인터페이스를 떠올릴 것이다. 맞다 결국은 각자의 인터페이스에 맞춰 준비된 상호작용을 멋지게 해내는 것! 그것이 객체지향답다고 할 수 있지 않을까?

## 설계의 천장
객체를 잘 만들면 그 개체는 마치 살아 숨 쉬며 어떤 작업을 수행하는 생명처럼 자율성을 부여할 수 있다. 그리고 그러한 객체들간의 협력을 잘 구성하면 해당 객체들이 유기적으로 상호작용하며 큰 문제를 작은 문제로 분해하여 해결할 수 있다. 많은 경우 위와 같은 사실들을 바탕으로 좋은 설계를 유지할 수 있지만 언제나 예외라는 것이 있듯 자율성과 의존성을 모두를 챙길 수 없는 상황이 적지 않아 있다. 이 때는 상황에 맞게 더 높은 가치를 선택해야 할 것이다.
